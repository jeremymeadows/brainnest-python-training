from functools import cache
import math


@cache  # memoize `is_prime` because it's called repetedly on some large values
def is_prime(n):
    if n == 0 or n == 1:
        return False
    elif n == 2:
        return True
    elif n & 1 == 0:
        return False

    for i in range(3, math.ceil(math.sqrt(n)) + 1, 2):
        if n % i == 0:
            return False
    return True


# the numbers are all small enough that this is still fast and a sieve isn't
# necessary
def prime_generator(limit=0, filter=lambda _: True):
    n = 1
    while limit == 0 or n < limit:
        n += 1
        if filter(n) and is_prime(n):
            yield n


def q_01():
    '''
    If we list all the natural numbers below 10 that are multiples of 3 or 5,
    we get 3, 5, 6 and 9. The sum of these multiples is 23.

    Find the sum of all the multiples of 3 or 5 below 1000.
    '''

    return sum([i for i in range(1000) if i % 3 == 0 or i % 5 == 0])


def q_02():
    '''
    Each new term in the Fibonacci sequence is generated by adding the previous
    two terms. By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5,
    8, 13, 21, 34, 55, 89

    By considering the terms in the Fibonacci sequence whose values do not
    exceed four million, find the sum of the even-valued terms.
    '''

    @cache  # memoize calls to `fib` so it doesn't need to recurse all the way
    def fib(n):
        if n < 1:
            raise ValueError('the Fibonacci sequence starts at index `1`')
        elif n == 1:
            return 1
        elif n == 2:
            return 2

        return fib(n - 1) + fib(n - 2)

    def fib_gen_even():
        n = 1
        while (value := fib(n)) <= 4_000_000:
            if value % 2 == 0:
                yield value
            n += 1

    return sum(fib_gen_even())


def q_03():
    '''
    The prime factors of 13195 are 5, 7, 13 and 29. What is the largest prime
    factor of the number 600851475143?
    '''

    num = 600_851_475_143

    primes = prime_generator(limit=(math.ceil(math.sqrt(num)) + 1))
    prime_factor_candidate = next(primes)
    remainder = num

    # I know that the remainder at the end will be the largest prime since all
    # of the smaller primes have already been divided out
    while not is_prime(remainder):
        if remainder % prime_factor_candidate == 0:
            remainder //= prime_factor_candidate
        else:
            prime_factor_candidate = next(primes)
    return remainder


def q_04():
    '''
    A palindromic number reads the same both ways. The largest palindrome made
    from the product of two 2-digit numbers is 9009 = 91 Ã— 99.

    Find the largest palindrome made from the product of two 3-digit numbers.
    '''

    digits = 3
    largest_palindrome = 0

    min_val = 10**(digits - 1)
    max_val = 10**digits

    for x in reversed(range(min_val, max_val)):
        for y in reversed(range(min_val, x)):
            if (z := str(x * y)) == z[::-1]:
                largest_palindrome = max(largest_palindrome, x * y)
                break
    return largest_palindrome


def q_05():
    '''
    2520 is the smallest number that can be divided by each of the numbers from
    1 to 10 without any remainder.

    What is the smallest positive number that is evenly divisible by all of the
    numbers from 1 to 20?
    '''

    num = 20
    value = num
    primes = list(prime_generator(limit=num))

    while not all(arr := [value % i == 0 for i in range(1, num + 1)]):
        # multiply the value by the smallest prime factor of any number which is not a factor
        value *= next(
            i for i in primes if (arr.index(False) + 1) % i == 0
        )
    return value


def q_06():
    '''
    The sum of the squares of the first ten natural numbers is, 1^2 + 2^2 +
    ... + 10^2 = 385 The square of the sum of the first ten natural numbers is,
    (1 + 2 + ... + 10)^2 = 3025.

    Hence the difference between the sum of the squares of the first ten natural
    numbers and the square of the sum is, 3025 - 385 = 2640.

    Find the difference between the sum of the squares of the first one hundred
    natural numbers and the square of the sum.
    '''

    count = 100
    sum_of_squares = sum([i ** 2 for i in range(1, count + 1)])
    square_of_sum = sum(range(1, count + 1)) ** 2
    return square_of_sum - sum_of_squares


def q_07():
    '''
    By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see
    that the 6th prime is 13.

    What is the 10001st prime number?
    '''

    n = 10001
    gen = prime_generator()

    for _ in range(n - 1):
        next(gen)
    return next(gen)


def q_08():
    '''
    A Pythagorean triplet is a set of three natural numbers, a < b < c, for
    which, a^2 + b^2 = c^2. For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.

    There exists exactly one Pythagorean triplet for which a + b + c = 1000.
    Find the product abc.
    '''

    target = 1000

    for a in range(1, target):
        for b in range(a, target):
            for c in range(b, target):
                if a + b + c == target and a**2 + b**2 == c**2:
                    return a * b * c


def q_09():
    '''
    The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.

    Find the sum of all the primes below two million.
    '''

    limit = 2_000_000
    return sum(prime_generator(limit))


def q_10():
    '''
    The sequence of triangle numbers is generated by adding the natural numbers.
    So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The
    first ten terms would be: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55.

    Let us list the factors of the first seven triangle numbers:

     1: 1
     3: 1,3
     6: 1,2,3,6
    10: 1,2,5,10
    15: 1,3,5,15
    21: 1,3,7,21
    28: 1,2,4,7,14,28
    We can see that 28 is the first triangle number to have over five divisors.

    What is the value of the first triangle number to have over five hundred divisors?
    '''

    divisor_threshold = 500

    ndx = 0
    number = 0
    divisors = 0

    while divisors < divisor_threshold:
        ndx += 1
        number += ndx
        divisors = 1 if ndx == 1 else 2

        for d in range(2, math.floor(math.sqrt(number))):
            if number % d == 0:
                divisors += 2
        if number % math.sqrt(number) == 0:
            divisors += 1
    return number


def main():
    # check my solutions for correctness against Wolfram Alpha
    expected_results = [
        233168,
        4613732,
        6857,
        906609,
        232792560,
        25164150,
        104743,
        31875000,
        142913828922,
        76576500,
    ]

    for ndx, (name, question) in enumerate(filter(lambda e: e[0].startswith('q_'), globals().items())):
        if (res := question()) == expected_results[ndx]:
            print(f'{name}: {res}')
        else:
            print(
                f'expected {name} to be {expected_results[ndx]} but got {res}'
            )


if __name__ == '__main__':
    main()
