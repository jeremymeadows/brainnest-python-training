from functools import cache
import math


def ex_01():
    '''
    If we list all the natural numbers below 10 that are multiples of 3 or 5,
    we get 3, 5, 6 and 9. The sum of these multiples is 23.

    Find the sum of all the multiples of 3 or 5 below 1000.
    '''

    print(sum([i for i in range(1000) if i % 3 == 0 or i % 5 == 0]))


def ex_02():
    '''
    Each new term in the Fibonacci sequence is generated by adding the previous
    two terms. By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5,
    8, 13, 21, 34, 55, 89

    By considering the terms in the Fibonacci sequence whose values do not
    exceed four million, find the sum of the even-valued terms.
    '''

    @cache  # memoize calls to `fib` so it doesn't need to recurse all the way
    def fib(n):
        if n < 1:
            raise ValueError('the Fibonacci sequence starts at index `1`')
        elif n == 1:
            return 1
        elif n == 2:
            return 2

        return fib(n - 1) + fib(n - 2)

    def fib_gen_even():
        n = 1
        while (value := fib(n)) <= 4_000_000:
            if value % 2 == 0:
                yield value
            n += 1

    print(sum(fib_gen_even()))


def ex_03():
    '''
    The prime factors of 13195 are 5, 7, 13 and 29. What is the largest prime
    factor of the number 600851475143?
    '''

    num = 600_851_475_143

    @cache  # memoize `is_prime` because I will call it repetadly
    def is_prime(n):
        if n == 0 or n == 1:
            return False
        elif n == 2:
            return True
        elif n & 1 == 0:
            return False

        # the numbers are small enough that this is still fast and a sieve isn't
        # necessary
        for i in range(3, math.ceil(math.sqrt(n)) + 1, 2):
            if n % i == 0:
                return False
        return True

    primes = (i for i in range(math.ceil(math.sqrt(num)) + 1) if is_prime(i))
    # prime_factors = []
    prime_factor_candidate = next(primes)
    remainder = num

    # because I only care about the latgest factor, I won't bother storing all
    # of them -- I know that the remainder at the end will be the largest prime
    # since all the smaller primes have already been divided out
    while not is_prime(remainder):
        if remainder % prime_factor_candidate == 0:
            remainder //= prime_factor_candidate
            # prime_factors.append(prime_factor_candidate)
        else:
            prime_factor_candidate = next(primes)
    # prime_factors.append(remainder)

    # print(max(prime_factors))
    print(remainder)


def ex_04():
    '''
    A palindromic number reads the same both ways. The largest palindrome made
    from the product of two 2-digit numbers is 9009 = 91 Ã— 99.

    Find the largest palindrome made from the product of two 3-digit numbers.
    '''

    digits = 3
    # largest_palindrome = {
    #     'value': 0,
    #     'x': None,
    #     'y': None,
    # }
    largest_palindrome = 0

    for x in reversed(range(10**(digits - 1), 10**digits)):
        for y in reversed(range(10**(digits - 1), x)):
            z = str(x * y)
            if z == z[::-1]:
                largest_palindrome = max(largest_palindrome, int(z))
                # if (z := int(z)) > largest_palindrome['value']:
                #     largest_palindrome = {
                #         'value': z,
                #         'x': x,
                #         'y': y,
                #     }
                break

    # print(f'{largest_palindrome["value"]} = {largest_palindrome["x"]} * {largest_palindrome["y"]}')
    print(largest_palindrome)


def ex_05():
    '''
    2520 is the smallest number that can be divided by each of the numbers from
    1 to 10 without any remainder.

    What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
    '''

    num = 20
    largest = num

    # hardcoded because there's just a few within our bounds
    prime_factors = [2, 3, 5, 7, 11, 13, 17, 19]

    while not all(arr := [largest % i == 0 for i in range(1, num + 1)]):
        largest *= next(
            i for i in prime_factors if (arr.index(False) + 1) % i == 0
        )

    print(largest)


def ex_06():
    '''
    The sum of the squares of the first ten natural numbers is, 1^2 + 2^2 +
    ... + 10^2 = 385 The square of the sum of the first ten natural numbers is,
    (1 + 2 + ... + 10)^2 = 3025.

    Hence the difference between the sum of the squares of the first ten natural
    numbers and the square of the sum is, 3025 - 385 = 2640.

    Find the difference between the sum of the squares of the first one hundred
    natural numbers and the square of the sum.
    '''

    count = 100
    sum_of_squares = sum([i ** 2 for i in range(1, count + 1)])
    square_of_sum = sum(range(1, count + 1)) ** 2
    print(square_of_sum - sum_of_squares)


def ex_07():
    '''
    By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see
    that the 6th prime is 13.

    What is the 10001st prime number?
    '''

    n = 10001

    def prime_generator(filter=lambda _: True):
        def is_prime(n):
            if n == 0 or n == 1:
                return False
            elif n == 2:
                return True
            elif n & 1 == 0:
                return False

            for i in range(3, math.ceil(math.sqrt(n)) + 1, 2):
                if n % i == 0:
                    return False
            return True

        n = 1
        while True:
            n += 1
            if filter(n) and is_prime(n):
                yield n

    gen = prime_generator()
    for _ in range(n - 1):
        next(gen)
    print(next(gen))


def ex_08():
    '''
    A Pythagorean triplet is a set of three natural numbers, a < b < c, for
    which, a^2 + b^2 = c^2. For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.

    There exists exactly one Pythagorean triplet for which a + b + c = 1000.
    Find the product abc.
    '''

    target = 1000

    for a in range(1, target):
        for b in range(a, target):
            for c in range(b, target):
                if a + b + c == target and a**2 + b**2 == c**2:
                    print(a * b * c)
                    break
            else:
                continue
            break
        else:
            continue
        break


def ex_09():
    '''
    The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.

    Find the sum of all the primes below two million.
    '''

    limit = 2_000_000

    def prime_generator(limit=0):
        def is_prime(n):
            if n == 0 or n == 1:
                return False
            elif n == 2:
                return True
            elif n & 1 == 0:
                return False

            for i in range(3, math.ceil(math.sqrt(n)) + 1, 2):
                if n % i == 0:
                    return False
            return True

        n = 1
        while limit == 0 or n < limit:
            n += 1
            if is_prime(n):
                yield n

    gen = prime_generator(limit)
    print(sum(gen))


def ex_10():
    '''
    The sequence of triangle numbers is generated by adding the natural numbers.
    So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The
    first ten terms would be: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55.

    Let us list the factors of the first seven triangle numbers:

     1: 1
     3: 1,3
     6: 1,2,3,6
    10: 1,2,5,10
    15: 1,3,5,15
    21: 1,3,7,21
    28: 1,2,4,7,14,28
    We can see that 28 is the first triangle number to have over five divisors.

    What is the value of the first triangle number to have over five hundred divisors?
    '''

    divisor_threshold = 500

    ndx = 0
    number = 0
    divisors = 0

    while divisors < divisor_threshold:
        ndx += 1
        number += ndx
        divisors = 1 if ndx == 1 else 2

        for d in range(2, math.floor(math.sqrt(number))):
            if number % d == 0:
                divisors += 2
        if number % math.sqrt(number) == 0:
            divisors += 1
    print(number)


def main():
    ex_01()
    ex_02()
    ex_03()
    ex_04()
    ex_05()
    ex_06()
    ex_07()
    ex_08()
    ex_09()
    ex_10()


if __name__ == '__main__':
    main()
